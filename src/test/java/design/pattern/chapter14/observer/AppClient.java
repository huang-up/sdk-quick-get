package design.pattern.chapter14.observer;

/**
 * 观察者模式（做发布／订阅模式）：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。
 * 这个主题对象在状态变化时，会通知所有观察者对象，使它们能够自动更新自己。
 *
 * 用观察者模式的动机是将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。
 * 我们不希望为了维护一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。
 *
 * 什么时候使用：
 * 1、当一个对象的改变需要同时改变其他对象。
 * 2、而且它不知道具体又多少对象有待改变时，应该考虑使用观察者模式。
 * 3、当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中，
 * 使它们各自独立的改变和复用。
 *
 * 观察者模式所做的工作其实就是解除耦合。
 * 让耦合的双方都依赖于抽象，而不是依赖于具体，从而是的各自的变化都不会影响另一边的变化。
 *
 *
 * 事件委托：
 * 委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该该方法具有完全相同的行为。
 * 委托方法的使用可以像其他任何方法一样，具有参数和返回值。
 * 委托可以看作是对函数的抽象，是函数的 '类'，委托的实例代表一个具体的函数。
 * 更重要的是，一个委托可以搭载多个方法，所有方法被依次唤起。它可以使得委托对象所搭载的方法并不需要属于同一个类。
 * 委托的前提是委托对象所搭载的所有方法必须具有相同的原形和形式，也就是拥有相同的参数列表和返回值类型。
 *
 * 先有观察者模式，再有委托事件技术。它们各有优缺点。
 *
 * Created by h on 2017/10/8.
 */
public class AppClient {
    public static void main(String[] args) {
        Boss boss = new Boss();
        boss.setSubjectState("老板回来了！");
        StockObserver stockObserver = new StockObserver("魏", boss);
        boss.attach(stockObserver);
        NbaObserver nbaObserver = new NbaObserver("易", boss);
        boss.attach(nbaObserver);
        boss.notifyObservers();
    }
}
